<?xml version="1.0" encoding="ISO-8859-1"?>
<document url="http://www.dom4j.org/faq.xml">
  <body>
    <title>Frequently Asked Questions</title>
    
    <section title="What is dom4j?">
      <p><i>dom4j</i> is an Open Source XML framework for Java.
      <i>dom4j</i> allows you to read, write, navigate, create and modify 
      XML documents. 
      <i>dom4j</i> integrates with DOM and SAX and is seamlessly integrated 
      with full XPath support.
      </p>
    </section>

    <section title="What is the dom4j license?">
      <p>We use an Apache-style open source license which is one of the least
        restrictive licenses around, you can use <i>dom4j</i> to create new products
        without them having to be open source.
      </p>
      <p>You can find a copy of the license <a href="license.html">here</a>.
      </p>
    </section>

    <section title="What do I need to add to my CLASSPATH?">
      <p>The dom4j-all.jar contains everything you need to use <i>dom4j</i> so that is 
        the only JAR you'll need to add to your CLASSPATH.
        No other JAR is necessary! <i>dom4j</i> comes complete with a default 
        SAX parser so its ready to run straight out of the box.</p>

      <p><i>dom4j</i> can use your existing XML parser and/or DOM implementation 
        (such as <a href="http://xml.apache.org/crimson/">Crimson</a> or 
        <a href="http://xml.apache.org/xerces-j/">Xerces</a> if you want it to. <i>dom4j</i> can also use
        <a href="http://java.sun.com/xml/">JAXP</a> to configure which SAX Parser to use - just add the 
        jaxp.jar to your CLASSPATH and whichever SAX parser you wish away you go.
      </p>
    </section>

    <section title="How does dom4j relate to DOM?">
      <p>DOM is a quite large language independent API.
        <i>dom4j</i> is a simpler, lightweight API which is optimised for the Java 
        making extensive use of the Java 2 platform such as the 
        Java 2 collections.
      </p>
      <p>Though <i>dom4j</i> fully supports the DOM standard allowing both APIs to be 
        used easily together.
      </p>
    </section>

    <section title="How does dom4j relate to JDOM?">
      <p><i>dom4j</i> is a different project and different API to JDOM
        though they both have similar goals. They both attempt to make it easier
        to use XML on the Java platform. 
        They differ in their design, API and implementation.
      </p>
      <p><i>dom4j</i> is based on Java interfaces so that plug and play 
        document object model implementations are allowed and encouraged
        such as small, read only, quick to create implementations or 
        bigger, highly indexed fast to naviagte implementations or 
        implementations which read themselves lazily from a database or 
        Java Beans etc.
      </p>
      <p><i>dom4j</i> uses polymorphism extensively such that all document object types 
        implement the Node interface. 
        Also both the Element and Document interfaces can be used polymorphically
        as they both extend the Branch interface.
      </p>

      <p><i>dom4j</i> is fully integrated with XPath support throughout the API 
        so doing XPath expressions is as easy as
      </p>
<pre>
SAXReader reader = new SAXReader();
Document document = reader.read( url );
List links = document.selectNodes( "//a[@href]" );
String title = document.valueOf( "/head/title" );
</pre>
      <p><i>dom4j</i> will soon provide a configuration option to
        support the W3C DOM API natively to avoid unnecessary tree duplication
        when using <i>dom4j</i> with XSLT engines etc.
      </p>
    </section>

    <section title="How does dom4j work with DOM and SAX?">
      <p>You can create <i>dom4j</i> documents from XML text, SAX events or existing 
        DOM trees or you can write <i>dom4j</i> documents as SAX events, DOM trees 
        or XML text.
      </p>
    </section>

    <section title="How can I use XSLT with dom4j?">
      <p><i>dom4j</i> integrates with XSLT using the JAXP standard (TrAX) APIs.
        A <i>dom4j</i> Document can be used as the source of XML to be styled or 
        the source of the stylesheet. 
        A <i>dom4j</i> Document can also be used as the result of a transformation. 
      </p>
      <p>First you'll need to use JAXP to load a Transformer.
      </p>
<pre>
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.stream.StreamSource;
import org.dom4j.Document;
import org.dom4j.DocumentResult;
import org.dom4j.DocumentSource;
...

TransformerFactory factory 
  = TransformerFactory.newInstance();

Transformer transformer 
  = factory.newTransformer( new StreamSource( "foo.xsl" ) );
</pre>
      <p>Now that you have a transformer its easy to style a Document into 
      a new Document.
      </p>
<pre>
DocumentSource source = new DocumentSource( document );
DocumentResult result = new DocumentResult();
transformer.transform( source, result );

Document transformedDoc = result.getDocument();
</pre>
      <p>If you want to transform a Document into XML text you can use JAXP as follows:-
      </p>
<pre>
DocumentSource source = new DocumentSource( document );
DocumentResult result = new StreamResult( new FileReader( "output.xml" ) );
transformer.transform( source, result );
</pre>
      <p>For more information on JAXP and (TrAX) try 
        <a href="http://java.sun.com/xml/">Sun's JAXP site</a>.
      </p>
    </section>

    <section title="How can I pretty print my XML document?">
      <p>You can control the format of the XML text output by
        <a href="apidocs/org/dom4j/io/XMLWriter.html">XMLWriter</a>
        by using the
        <a href="apidocs/org/dom4j/io/OutputFormat.html">OutputFormat</a>
        object.
        You can explicitly set the various formatting options via the 
        properties methods of the OutputFormat object. There is also a helper
        method <code>OutputFormat.createPrettyPrint()</code> which creates 
        the default pretty-print format.
      </p>
      <p>So to pretty print some XML (trimming all whitespace and indenting nicely)
        the following code should do the job...
      </p>
<pre>
    OutputFormat format = OutputFormat.createPrettyPrint();
    XMLWriter writer = new XMLWriter( out, format );
    writer.write( document );
    writer.close();
</pre>
    </section>

    
    <section title="How can I parse a document from a String?">
      <p>Sometimes you have a String (or StringBuffer) which contains the XML 
        to be parsed. This can be parsed using <code>SAXReader</code>
        and the <code>StringReader</code> from the JDK. For example:-
      </p>
      <pre>
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.DocumentHelper;

public class Foo {

    public Document getDocument() throws DocumentException {
        return DocumentHelper.parseText( 
            "&lt;root&gt; &lt;child id='1'&gt;James&lt;/child&gt; &lt;/root&gt;"
        );
    }
}
      </pre>
    </section>


    <section title="How does dom4j handle very large XML documents?">
      <p><i>dom4j</i> provides an event based model for processing XML documents.
        Using this event based model allows developers to prune the XML tree
        when parts of the document have been successfully processed avoiding
        having to keep the entire document in memory.
      </p>
      <p>For example, imagine you need to process a very large XML file that is 
        generated externally by some database process and looks something like 
        the following (where N is a very large number).
      </p>
      <pre>
<![CDATA[<ROWSET>
    <ROW id="1">
        ...
    </ROW>
    <ROW id="2">
        ...
    </ROW>
    ...
    <ROW id="N">
        ...
    </ROW>
</ROWSET>]]>     
      </pre>
      <p>We can process each &lt;ROW&gt; at a time, there is no 
        need to keep all of them in memory at once.
        <i>dom4j</i> provides a <i>Event Based Mode</i> for this purpose. 
        We can register an event handler for one or more path expressions.
        These handlers will then be called on the start and end of each path
        registered against a particular handler.  When the start tag of a 
        path is found, the onStart method of the handler registered to the 
        path is called.  When the end tag of a path if found, the onEnd method 
        of the handler registered to that path is called.
      </p>
      <p>
        The onStart and onEnd methods are passed an instance of an ElementPath,
        which can be used to retrieve the current Element for the given path.
        If the handler wishes to "prune" the tree being built in order to 
        save memory use, it can simply call the detach() method of the current
        Element being processed in the handlers onEnd() method.
      </p>
      <p>
        So to process each &lt;ROW&gt; individually we can do the following.
      </p>
      <pre>
// enable pruning mode to call me back as each ROW is complete
SAXReader reader = new SAXReader();
reader.addHandler( "/ROWSET/ROW", 
    new ElementHandler() {
        public void onStart(ElementPath path) {
            // do nothing here...    
        }
        public void onEnd(ElementPath path) {
            // process a ROW element
            Element row = path.getCurrent();
            Element rowSet = row.getParent();
            Document document = row.getDocument();
            ...
            // prune the tree
            row.detach();
        }
    }
);

Document document = reader.read(url);

// The document will now be complete but all the ROW elements
// will have been pruned.
// We may want to do some final processing now
...
      </pre>
    </section>


    <section title="Does dom4j support the Visitor Pattern?">
      <p>Yes. <i>dom4j</i> supports the visitor pattern via the 
          <a href="apidocs/org/dom4j/Visitor.html">Visitor</a> interface.
      </p>
      <p>Here is an example.
      </p>
      <pre>
protected void foo(Document doc) {
  
    // lets use the Visitor Pattern to 
    // navigate the document for entities

    Visitor visitor = new VisitorSupport() {
        public void visit(Entity entity) {
            System.out.println( 
                "Entity name: " + entity.getName() 
                + " text: " + entity.getText() 
            );
        }
    };

    doc.accept( visitor );
}
      </pre>
    </section>


    <section title="Can I sort the List returned by Node.selectNodes()?">
      <p>Yes. The selectNodes() is a really useful feature to allow nodes to be
        selected from any object in the <i>dom4j</i> object model via an XPath expression. 
        The List that is returned can be sorted by
        specifying another XPath expression to use as the sorting comparator.
      </p>
      <p>
      For example the following code parses an XML play and finds all the
      SPEAKER elements sorted in name order. 
      </p>
      <pre>
SAXReader reader = new SAXReader();
Document document = reader.read( new File( "xml/much_ado.xml" ) );
List speakers = document.selectNodes( "//SPEAKER", "." );
      </pre>
      <p>
      In the above example the name of the SPEAKER is
      defined by the XPath expression "." as the name is stored in the text 
      of the SPEAKER element. 
      If the name was defined by an attribute called "name" then 
      the XPath expression "@name" should be used for sorting.
      </p>
      <p>
      You may wish to remove duplicates while sorting such that (for example)
      the distinct list of SPEAKER elements is returned, sorted by name.
      To do this add an extra parameter to the selectNodes() method call.
      </p>
      <pre>
List distinctSpeakers = document.selectNodes( "//SPEAKER", ".", true );
      </pre>
    </section>


    <section title="What features are optional in dom4j?">
      <p>In <i>dom4j</i> being able to navigate up a tree towards the parent
        and to be able to change a tree are optional features. 
        These features are optional so that an implementation
        can create memory efficient read only document models which
        conserve memory by sharing imutable objects (such as interning 
        Atttributes).
      </p>
        
      <p>There are some helper methods to determine if optional features are 
        implemented. 
        Here is some example code demonstrating their use.
      </p>
      <pre>
protected void foo(Node node) {
  
    // can we do upward navigation?
    if ( ! node.supportsParent() ) {
        throw new UnsupportedOperationException(
          "Cannot navigate upwards to parent"
        );
    }
    Element parent = node.getParent();

    System.out.println( "Node: " + node 
        + " has parent: " + parent 
    );

    if ( parent != null ) {

        // can I modify the parent?
        if ( parent.isReadOnly() ) {
            throw new UnsupportedOperationException(
              "Cannot modify parent as it is read only"
            );
        }

        parent.setAttributeValue( "bar", "modified" );
    }
}
      </pre>
    </section>

  </body>
</document>









