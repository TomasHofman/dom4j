<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.0//EN"
               "http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd">
<book>
<bookinfo>
<title>dom4j cookbook</title>
<authorgroup>
  <author><honorific>Mr</honorific><firstname>Tobias</firstname><surname>Rademacher</surname></author>
  <author><honorific>Mr</honorific><firstname>James</firstname><surname>Strachan</surname></author>
</authorgroup>
<revhistory>
  <revision>
      <revnumber>0.0.8</revnumber>
      <date>01-09-25</date>
      <authorinitials>tradem</authorinitials>
      <revdescription>
         <para>Fixed the MSV sample in order make it compilable. Lot's of thanks to Martijn Koster for pointing that out.</para>
      </revdescription>
  </revision>
 <revision>
    <revnumber>0.0.7</revnumber>
    <date>01-09-03</date>
    <authorinitials>tradem</authorinitials>
    <revdescription>
      <itemizedlist>
        <listitem><para>Completed the Schema chapter.</para></listitem>
        <listitem><para>Fixed the XPath sample.</para></listitem>
      </itemizedlist>
    </revdescription>
  </revision>
  <revision>
    <revnumber>0.0.6</revnumber>
    <date>01-08-03</date>
    <authorinitials>jstrachan</authorinitials>
    <revdescription>
      <itemizedlist>
        <listitem><para>Fixed a few typos and corrected the odd bit of grammar and code.</para></listitem>
      </itemizedlist>
    </revdescription>
  </revision>
  <revision>
    <revnumber>0.0.5</revnumber>
    <date>01-07-09</date>
    <authorinitials>tradem</authorinitials>
    <revdescription>
      <itemizedlist>
        <listitem><para>Fixing xml structure mistake</para></listitem>
        <listitem><para>Make Writer samples dom4j 0.6 compliant</para></listitem>
      </itemizedlist>
    </revdescription>
  </revision>
<revision>
    <revnumber>0.0.4</revnumber>
    <date>01-07-06</date>
    <authorinitials>tradem</authorinitials>
    <revdescription>
      <itemizedlist>
        <listitem><para>Fixing spelling/gramma mistakes</para></listitem>
        <listitem><para>Complete vistor listing</para></listitem>
      </itemizedlist>
    </revdescription>
</revision>
<revision>
  <revnumber>0.0.3</revnumber>
  <date>01-06-20</date>
  <authorinitials>tradem</authorinitials>
  <revdescription>
    <para>Completed doc for alpha release</para>
  </revdescription>
</revision>
<revision>
  <revnumber>0.0.2</revnumber>
  <date>01-06-06</date>
  <authorinitials>tradem</authorinitials>
  <revdescription>
    <para>Added "Secret of DocumentBuilder" and "Serialization"</para>
  </revdescription>
</revision>
<revision>
  <revnumber>0.0.1</revnumber>
  <date>01-06-02</date>
  <authorinitials>tradem</authorinitials>
  <revdescription>
    <para>Created the document</para>
  </revdescription>
  </revision>
</revhistory>
<pubdate>September 2001</pubdate>
<abstract>
  <para>This document provides a practical introduction to dom4j. It guides you through by using a lot of examples and is based on dom4j v1.0</para>
</abstract>
</bookinfo>
<preface>
  <title>Foreword</title>
<para>
</para>
</preface>
<chapter>
<title>Introducing dom4j</title>
<para>
<application>dom4j</application> is a object model representing an XML Tree in memory.
<application>dom4j</application> offers a easy-to-use API that provides a powerfull set of
features to process, manipulate or navigate XML and work with XPath and XSLT as well as integrate with SAX, JAXP and DOM.
</para>
<para>
<application>dom4j</application> is designed to be interface-based in order to provide highly configurable implementation strategies.
You are able to create your own XML tree implementations by simply providing a DocumentFactory implementation.
This makes it very simple to resuse much of the dom4j code while extending it to provide whatever implementation features you wish.
</para>
<para>
This
document will guide you through <application>dom4j</application>'s features in a pratical way.
It uses a lot of examples with source code to achive that. The document is
also desinged as a reference so that you don't have to read the entire document right now. This guide concentrates on daily work with
<application>dom4j</application> and is therefore called <emphasis>cookbook</emphasis>.
</para>
</chapter>
<chapter>
<title>Creation of an XML Object Model using dom4j</title>
<para>
Normally it all starts with a set of xml-files or a single xml file that you want to process, manipulate or navigate through to extract some
values necessary in your application. Most Java Open-Source projects using XML for deployment or as a replacement for property files in order
to get easily readable property data.
</para>

<section><title>Reading XML data</title>
<para>
How does <application>dom4j</application> help you to get at the data stored in XML?
<application>dom4j</application> comes with a set of
builder classes that parses the xml data and creating
a tree like object structure in memory.
You can easily manipulate and navigate through that model.
The following example shows how you can
read your data using <application>dom4j</application> API.

<programlisting>
import java.io.File;
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.io.SAXReader;

public class DeployFileLoaderSample {

  /** dom4j object model representation of a xml document. Note: We use the interface(!) not its implementation */
  private Document doc;

  /**
   * Loads a document from a file.
   *
   * @throw a org.dom4j.DocumentException occurs whenever the buildprocess fails.
   */
  public void parseWithSAX(File aFile) throws DocumentException {
    SAXReader xmlReader = new SAXReader();
    this.doc = xmlReader.read(aFile);
  }
}
</programlisting>

</para>

<para>
The above example code should clarify the use of <classname>org.dom4j.io.SAXReader</classname> to
build a complete <application>dom4j</application>-tree from a given file.
The org.dom4j.io package of <application>dom4j</application> contains a set of classes
for creating and serializing <acronym>XML</acronym> objects.
The read() method
is overloaded so that you able to pass different kind of object that represents a source.
</para>

<itemizedlist>
  <listitem><para><classname>java.lang.String</classname> - a SystemId is a String that contains a URI e.g. a URL to a XML file</para></listitem>
  <listitem><para><classname>java.net.URL</classname> - represents a Uniform Ressource Loader or a Uniform Ressource Identifier encasulate in a URL instance</para></listitem>
  <listitem><para><classname>java.io.InputStream</classname> - a open input stream that transports xml data</para></listitem>
  <listitem><para><classname>java.io.Reader</classname> - more compartable puls the abiltiy of setting the encoding scheme</para></listitem>
  <listitem><para><classname>org.sax.InputSource</classname> - a single input source for a <acronym>XML</acronym> entity.</para></listitem>
</itemizedlist>

<para>
So we decide to add more flexiblity to our <classname>DeployFileLoaderSample</classname> and add new methods.
</para>

<programlisting>
import java.io.File;

import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.io.SAXReader;

public class DeployFileLoaderSample {

  /** dom4j object model representation of a xml document. Note: We use the interface(!) not its implementation */
  private Document doc;

  /**
   * Loads a document from a file.
   *
   * @param aFile the data source
   * @throw a org.dom4j.DocumentExcepiton occurs whenever the buildprocess fails.
   */
  public void parseWithSAX(File aFile) throws DocumentException {
    SAXReader xmlReader = new SAXReader();
    this.doc = xmlReader.read(aFile);
  }

  /**
   * Loads a document from a file.
   *
   * @param aURL the data source
   * @throw a org.dom4j.DocumentExcepiton occurs whenever the buildprocess fails.
   */
  public void parseWithSAX(URL aURL) throws DocumentException {
    SAXReader xmlReader = new SAXReader();
    this.doc = xmlReader.read(aURL);
  }


}
</programlisting>

</section>

<section>
<title>Integrating with other XML APIs</title>
<para>
<application>dom4j</application> offers also classes for integration with
the two original XML processing APIs - SAX and DOM.
So far we have been talking about reading a document with SAX.
The <classname>org.dom4j.SAXContentHandler</classname> class implements several
SAX interfaces directly (such as ContentHandler) so that you can embed <application>dom4j</application>
directly inside any SAX application.
You can also use this class to implement your own specific SAX-based Reader class if you need to.
</para>

<para>
The <classname>DOMReader</classname> class allows you to convert an existing <acronym>DOM</acronym> tree
into a <application>dom4j</application> tree.
This could be usefull if you already used DOM and want to replace it step by step
with <application>dom4j</application> or if you just needs some of <acronym>DOM</acronym>'s
behaviour and want to save memory ressources by transforming it in a <application>dom4j</application> Model.
You are able to transform a DOM Document, a <acronym>DOM</acronym> node branch and a single element.
</para>

<programlisting>
import org.sax.Document;

import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.io.DOMReader;

public class DOMIntegratorSample {

  /** converts a W3C DOM document into a dom4j document */
  public Document buildDocment(org.w3c.dom.Document domDocument) {
    DOMReader xmlReader = new DOMReader();
    return xmlReader.read(domDocument);
  }
}

</programlisting>
</section>

<section><title>The secret of DocumentFactory</title>
Right now we have talked a lot of reading exisiting XML information e.g. from files, URL's or even Streams.
Sometimes it's necessary to generate a XML document from scratch within a running Java Application.
The class <classname>org.dom4j.DocumentFactory</classname> defines a set of factory methods to create documents, document
types, elements, attributes, unparsed character data (CDATA), a namespace, an <acronym>XPath</acronym> object, a NodeFilter and
some other useful instances. This makes the <classname>DocumentFactory</classname> class to a central class whenever you have to create
one of these instances by yourself.
</section>

<programlisting>

import org.dom4j.DocumentFactory;
import org.dom4j.Document;
import org.dom4j.Element;

public class DeployFileCreator {

  private DocumentFactory factory = DocumentFactory.getInstance();
  private Document doc;

  public void generateDoc(String aRootElement) {
    doc = DocumentFactory.getInstance().createDocument();
    Element root = doc.addElement(aRootElement);
  }

}

</programlisting>

<para>
The listing shows how to generate a new Document from scratch.
The method <classname>generateDoc(String aRootElement)</classname> takes a String parameter.
The string value contains the name of the root element of the new document.
As you can see <classname>org.dom4j.DocumentFactory</classname> is a singleton
that is accessable via <classname>getInstance()</classname> as most Java singletons are.
After we obtained the instance we can <classname>DocumentFactory</classname> methods.
They follow the <emphasis>createXXX()</emphasis> naming convention, so if you want to create a Attribute you would
call <emphasis>createAttribute()</emphasis> instead.
If your class uses DocumentFactory a lot or uses a different DocumentFactory instance then
you could add it as a member variable and initiate it via getInstance in your constructor.
</para>

<programlisting>

import org.dom4j.DocumentFactory;
import org.dom4j.Document;
import org.dom4j.Element;

public class GranuatedDeployFileCreator {

 private DocumentFactory factory;
 private Document doc;

 public GranuatedDeployFileCreator() {
   this.factory = DocumentFactory.getInstance();
 }

 public void generateDoc(String aRootElement) {
    doc = factory.createDocument();
    Element root = doc.addElement(aRootElement);
 }

}

</programlisting>



<para>
The <classname>Document</classname> and <classname>Element</classname>
interfaces have a number of helper methods for creating an XML document programmatically
in a simple way.
</para>

<programlisting>

import org.dom4j.Document;
import org.dom4j.DocumentHelper;
import org.dom4j.Element;

public class Foo {

  public Document createDocument() {
    Document document = DocumentHelper.createDocument();
    Element root = document.addElement( "root" );

    Element author2 = root.addElement( "author" )
      .addAttribute( "name", "Toby" )
      .addAttribute( "location", "Germany" )
      .addText( "Tobias Rademacher" );

    Element author1 = root.addElement( "author" )
      .addAttribute( "name", "James" )
      .addAttribute( "location", "UK" )
      .addText( "James Strachan" );

    return document;
  }
}

</programlisting>



<para>
As mentioned earlier <application>dom4j</application> is an interface based API.
This means that DocumentFactory and the reader classes in the org.dom4j.io package always use the org.dom4j interfaces
rather than any concrete implementation classes.
The Collection API and <acronym>W3C</acronym>'s <acronym>DOM</acronym> are other examples of APIs that
use this design aproach.
This wide spread design is described by <citation>BillVenners</citation>.
</para>

</chapter>

<chapter>
<title>Serialization and Output</title>

<para>
Once you have parsed or created a document you want to serialize it to disk or
into a plain (or encrypted) stream. <application>dom4j</application> provides a set of classes to serialize
your dom4j tree in four ways:
</para>

<itemizedlist>
  <listitem><para>XML</para></listitem>
  <listitem><para>HTML</para></listitem>
  <listitem><para>DOM</para></listitem>
  <listitem><para>SAX Events</para></listitem>
</itemizedlist>

<section><title>Serializing to XML</title>
<classname>org.dom4j.io.XMLWriter</classname> is a easy-to-use and easy-to-understand class used
to serialize a <application>dom4j</application> tree to a plain <acronym>XML</acronym>.
You are able
to write the <acronym>XML</acronym> tree to either an <classname>java.io.OutputStream</classname>
or a <classname>java.io.Writer</classname>.
This can be configured with the overloaded constructor or via the
<classname>setOutputStream()</classname> or <classname>setReader()</classname> methods.
Let's have a look at a example.

<programlisting>

import java.io.OutputStream;

import org.dom4j.Document;
import org.dom4j.io.XMLWriter;
import org.dom4j.io.OutputFormat;

public class DeployFileCreator {

 private Document doc;

 public void serializetoXML(OutputStream out, String aEncodingScheme) throws Exception {
   OutputFormat outformat = OutputFormat.createPrettyPrint();
   outformat.setEncoding(aEncodingScheme);
   XMLWriter writer = new XMLWriter(out, outformat);
   writer.write(this.doc);
   writer.flush();
 }

}
</programlisting>

<para>
We use the constructor of <classname>XMLWriter</classname> to pass a to given
<classname>OutputStream</classname> along with the required character encoding.
It is easier to use a <classname>Writer</classname> rather than an <classname>OutputStream</classname>,
because the <classname>Writer</classname>  is String based and so has ness
character encoding issues.
The write() methods of <classname>Writer</classname> are overloaded so that you can write all of the dom4j objects individually if required.
</para>


<section><title>Customizing the output format</title>
<para>
The default output format is to write the XML document as-is.
If you want to change the output format then there is a class
<classname>org.dom4j.io.OutputFormat</classname> which allows you to define pretty printing options,
to suppress the output of the XML declaration, change the line ending and so on.
There is also a helper method <classname>OutputFormat.createPrettyPrint()</classname> which will
create a default pretty printing format that you can further customize if you wish.
</para>


<programlisting>

import java.io.OutputStream;

import org.dom4j.Document;
import org.dom4j.io.XMLWriter;
import org.dom4j.io.OutputFormat;

public class DeployFileCreator {

 private Document doc;

  public void serializetoXML(OutputStream out, String aEncodingScheme) throws Exception {
   OutputFormat outformat = OutputFormat.createPrettyPrint();
   outformat.setEncoding(aEncodingScheme);
   XMLWriter writer = new XMLWriter(out, outformat);
   writer.write(this.doc);
   writer.flush();
 }


}
</programlisting>

<para>
An interesting feature of <classname>OutputFormat</classname> the ability to set
the character encoding. It is a good idiom to use this mechansim for setting the encoding
as the XMLWriter will be able to use this encoding to create an OutputStream as well
as to output the XML declaration.
</para>

<para>
The <classname>close()</classname> method closes the underlying <classname>Writer</classname>.
</para>

<programlisting>

import java.io.OutputStream;

import org.dom4j.Document;
import org.dom4j.io.XMLWriter;
import org.dom4j.io.OutputFormat;

public class DeployFileCreator {

 private Document doc;
 private OutputFormat outFormat;

 public DeployFileCreator() {
   this.outFormat = OuputFormat.getPrettyPrinting();
 }

 public DeployFileCreator(OutputFormat outFormat) {
   this.outFormat = outFormat;
 }

 public void writeAsXML(OutputStream out) throws Exception {
   XMLWriter writer = new XMLWriter(outFormat, this.outFormat);
   writer.write(this.doc);
 }

 public void writeAsXML(OutputStream out, String encoding) throws Exception {
   this.outFormat.setEncoding(encoding);
   this.writeAsXML(out);
 }

}
</programlisting>

<para>
The serialization methods in our little example will now set encoding using <classname>OutputFormater</classname>.
The default encoding if none is specifed will be <acronym>UTF-8</acronym>.
If you need a simple output on screen for debbuing or testing you can omit setting of
a <classname>Writer</classname> or an <classname>OutputStream</classname> completely
as <classname>XMLWriter</classname> will default to <classname>System.out</classname>.
</para>

</section>

</section>

<section><title>Printing HTML</title>
<para>
<classname>HTMLWriter</classname> takes a <application>dom4j</application> tree
and formats it to a stream as <acronym>HTML</acronym>. This formatter is similar to
<classname>XMLWriter</classname> but outputs the text of CDATA and Entity sections rather than the serialised
format as in <acronym>XML</acronym> and also supports many HTML element which have no corresponding close tag
such as for &lt;BR&gt; and &lt;P&gt;
</para>

<programlisting>

import java.io.OutputStream;

import org.dom4j.Document;
import org.dom4j.io.HTMLWriter;
import org.dom4j.io.OutputFormat;

public class DeployFileCreator {

 private Document doc;
 private OutputFormat outFormat;

 public DeployFileCreator() {
   this.outFormat = OuputFormat.getPrettyPrinting();
 }

 public DeployFileCreator(OutputFormat outFormat) {
   this.outFormat = outFormat;
 }

 public void writeAsHTML(OutputStream out) throws Exception {
   HTMLWriter writer = new HTMLWriter(outFormat, this.outFormat);
   writer.write(this.doc);
   writer.flush();
 }

}
</programlisting>

</section>

<section><title>Building a DOM tree</title>
<para>
Sometimes it's necessary to transform your <application>dom4j</application> tree
into a <acronym>DOM</acronym> tree, because you are currently refactoring your application.
<application>dom4j</application> is very convient for integration with older <acronym>XML</acronym>
<acronym>API</acronym>'s like <acronym>DOM</acronym> or <acronym>SAX</acronym>
(see <anchor id="dom4j2SAX">Generating SAX Events</anchor>). Let's move to an example:
</para>

<programlisting>
import org.w3c.dom.Document;

import org.dom4j.Document;
import org.dom4j.io.DOMWriter;

public class DeployFileLoaderSample {

  private org.dom4j.Document doc;

  public org.w3c.dom.Document transformtoDOM() {
    DOMWriter writer = new DOMWriter();
    return writer.write(this.doc);
  }
}

</programlisting>

</section>

<section id="dom4j2SAX"><title>Generating SAX Events</title>
<para>
If you want to output a document as sax events in order to integrate with some existing SAX
code, you can use the <classname>org.dom4j.SAXWriter</classname> clas.
</para>


<programlisting>
import org.xml.ConentHandler;

import org.dom4j.Document;
import org.dom4j.io.SAXWriter;

public class DeployFileLoaderSample {

  private org.dom4j.Document doc;

  public void transformtoSAX(ContentHandler ctxHandler) {
     SAXWriter writer = new SAXWriter();
     writer.setContentHandler(ctxHandler);
     writer.write(doc);
  }
}

</programlisting>

<para>
Using <classname>SAXWriter</classname> is fairly easy as you can see.
You can resolve also <classname>org.dom.Element</classname> which means that
you are able to process a single element branch or even a single node with <acronym>SAX</acronym>.
</para>
</section>
</chapter>

<chapter>
<title>Navigation in dom4j</title>
<para>
dom4j offers several powerful mechansims for navigating through a document:-
</para>

<itemizedlist>
  <listitem><para>Using Iterators</para></listitem>
  <listitem><para>Fast index based navigation</para></listitem>
  <listitem><para>Using a backed List</para></listitem>
  <listitem><para>Using XPath</para></listitem>
  <listitem><para>In-Build GOF Visitor Pattern</para></listitem>
</itemizedlist>

<section><title>Using Iterator</title>
<para>
Most Java developers have already used java.util.Iterator or it's ancestor
<classname>java.util.Enumeration</classname>.
Both classe are fairly involed into the Collection API and used
to visit the elements of a collection. The Iterator is appylied usually with a while
loop and Iterator methods hasNext() and next() item. Right now Collection API
dont support Generic Type (like C++ Templates), but there's already a Early Access Implemention available.
Now let's move to an living example of it in dom4j.
</para>
</section>

<programlisting>

import java.util.Iterator;

import org.dom4j.Document;
import org.dom4j.Element;

public class DeployFileLoaderSample {

  private org.dom4j.Document doc;
  private org.dom4j.Element root;

  public void iterateRootChildren() {
    root = this.doc.getRootElement();
    Iterator elementIterator = root.elementIterator();
    while(elementIterator.hasNext()){
      Element elmeent = (Element)elementIterator.next();
      System.out.println(element.getName());
    }
  }
}
</programlisting>

<para>
The above example might be a little bit confusing if you are not too familiar with the Collections API.
Casting is necessary when you want to acess the object. Java Generics will solve this problem in future.
</para>

<programlisting>
import java.util.Iterator;

import org.dom4j.Document;
import org.dom4j.Element;

public class DeployFileLoaderSample {

  private org.dom4j.Document doc;
  private org.dom4j.Element root;

  public void iterateRootChildren(String aFilterElementName) {
    root = this.doc.getRootElement();
    Iterator elementIterator = root.elementIterator(aFilterElementName);
    while(elementIterator.hasNext()){
      Element elmeent = (Element)elementIterator.next();
      System.out.println(element.getName());
    }
  }
}
</programlisting>

<para>
Now the the method iterates on such Elements that have the <emphasis>same name</emphasis> as the parameterized String only. This can be used as a kind of
filter applied on top of Collection API's Iterator.
</para>

<section><title>Fast index based Navigation</title>
<para>
Sometimes if you need to walk a large tree very quickly, creating an <classname>java.io.Iterator</classname>
instance to loop through each <classname>Element</classname>'s children can be expensive in
high performance environment.
To help this situation, <application>dom4j</application> provides a fast index based looping as follows.
</para>

<programlisting>
  public void treeWalk(Document document) {
    treeWalk( document.getRootElement() );
  }

  public void treeWalk(Element element) {
    for ( int i = 0, size = element.nodeCount(); i &lt; size; i++ ) {
      Node node = element.node(i);
      if ( node instanceof Element ) {
        treeWalk( (Element) node );
      }
      else {
        // do something....
      }
    }
  }
</programlisting>


<section><title>Using a backed List</title>
<para>
You can navigate through an <classname>Element</classname>'s children
using a backed <classname>List</classname> such that modifications to the
<classname>List</classname> are reflected back into the <classname>Element</classname>.
It also means that all of the methods on <classname>List</classname> can be used.
</para>

<programlisting>
import java.util.List;

import org.dom4j.Document;
import org.dom4j.Element;

public class DeployFileLoaderSample {

  private org.dom4j.Document doc;

  public void iterateRootChildren() {
    Element root = doc.getRootElement();

    List elements = root.elements;

    // we have access to the size() and other List methods
    if ( elements.size() > 4 ) {
      // now lets remove a range of elements
      elements.subList( 3, 4 ).clear();
    }
  }
}
</programlisting>

</section>

<section><title>Using XPath</title>
<para>
<acronym>XPath</acronym> is is one of the most usefull features of <application>dom4j</application>.
You can use it to retrieve nodes from any location as well as evaluating complex expressions.
A good XPath refercence can be found in Micheal Kay's XSLT book <citation>XSLTReference</citation>
along with the <citation>Zvon</citation> Zvon tutorial.
</para>
</section>

<programlisting>
import java.util.Iterator;

import org.dom4j.Documet;
import org.dom4j.DocumentHelper;
import org.dom4j.Element;
import org.dom4j.XPath;

public class DeployFileLoaderSample {

  private org.dom4j.Document doc;
  private org.dom4j.Element root;

  public void browseRootChildren() {
    XPath xpathSelector = DocumentHelper.createXPath("/people/person[@name='James']");
    List results = xpathSelector.selectNodes(doc);
    for ( Iterator iter = result.iterator(); iter.hasNext(); ) {
      Element element = (Element) iter.next();
      System.out.println(element.getName();
    }

<!-- won't work in dom4j 1.0 - Document interface has no method "valueOf(..)" and no "numberValueOf(..)"
    String address = doc.valueOf( "//person[@name='Toby']/address" );
    Number count = doc.numberValueOf( "//people[@location='London']" );
-->
  }

}
</programlisting>

<para>
As selectNodes returns a List we can apply <classname>Iterator</classname>
or any other operation avaliable on <classname>java.util.List</classname>.
<!--  won't work in dom4j 1.0 - Document interface has no method "valueOf(..)" and no "numberValueOf(..)"
You can also select a single node via <classname>selectSingleNode()</classname>
as well as to select a String expression via <classname>valueOf()</classname>
or Number
value of an XPath expression via <classname>numberVvalueOf()</classname>.
-->
</para>


<section><title>Using Visitor Pattern</title>
<para>
The visitor pattern has a recrusive behavior and acts like <acronym>SAX</acronym>
in the way that partical traversal is <emphasis>not</emphasis> possible.
This means the complete document or the complete element branch will be visited.
 You should consider wisely when you want to use Visitor pattern, but then it
offers a powerful and elegant way of navigation.
This document doesn't explain Vistor Pattern in deepth,
<citation>GoF98</citation> covers more information.
</para>

<programlisting>
import java.util.Iterator;

import org.dom4j.Visitor;
import org.dom4j.VisitorSupport;
import org.dom4j.Document;
import org.dom4j.Element;

public class VisitorSample {

  public void demo(Document doc) {

    Visitor visitor = new VisitorSupport() {
      public void visit(Element element) {
        System.out.println(
          "Entity name: " + element.getName()  + "text " + element.getText();
        );
      }
    };

    doc.accept( visitor );
  }
}

</programlisting>

<para>
As you can see we used a anonymous inner class to override the
<classname>VisitorSupport</classname> callback adapter method
visit(Element element) and the accept() method starts
the vistor mechansim.
Please keep in mind that the <emphasis>complete</emphasis> element branch is visited.
</para>
</section>
</section>
</chapter>


<chapter><title>Manipulating dom4j</title>
<para>
Accessing XML content statically alone would not very special. Thus dom4j offers several methods for manipulation a documents content.
</para>

<section><title>What <classname>org.dom4j.Document</classname> provides</title>
<para>
A <classname>org.dom4j.Document</classname> allows you to configure and retreive the root element.
You are also able to set the DOCTYPE or a SAX based <classname>EntityResolver</classname>.
An empty <classname>Document</classname> should be created via <classname>org.dom4j.DocumentFactory</classname>.
</para>
</section>

<section><title>Working with <classname>org.dom4j.Element</classname></title>
<para>
<classname>org.dom4j.Element</classname> is a powerfull interface providing lots of methods for manipulation an Element.
</para>

<programlisting>

  public void changeElementName(String aName) {
    this.element.setName(aName);
  }

  public void changeElementText(String aText) {
    this.element.setText(aText);
  }

</programlisting>
</section>


  <section><title>Qualified Names</title>
  <para>
  An XML Element should have a qualified name. A qualified name consits normally of a Namespace and a
  local name. It's recommend to use <classname>org.dom4j.DocumentFactory</classname> to create Qualifed
  Names that are provided by <classname>org.dom4j.QName</classname> instances.
  </para>

  <programlisting>

  import org.dom4j.Element;
  import org.dom4j.Document;
  import org.dom4j.DocumentFactory;
  import org.dom4j.QName;

  public class DeployFileCreator {

   protected Document deployDoc;
   protected Element root;

   public void DeployFileCreator()
   {
     QName rootName = DocumentFactory.getInstance().createQName("preferences", "", "http://java.sun.com/dtd/preferences.dtd");
     this.root = DocumentFactory.getInstance().createElement(rootName);
     this.deployDoc = DocumentFactory.getInstance().createDocument(this.root);
   }
  }

  </programlisting>

  </section>

  <section><title>Inserting elements</title>
  <para>
  Somethimes it's necessary to insert an element somewhere in a existing XML Tree. As dom4j is based on Collection API this
  causes no problems. The following expample shows how it could be done.
  </para>

  <programlisting>

    public void insertElementAt(Element newElement, int index) {
      Element parent = this.element.getParent();
      List list = parent.content();
      list.add(index, newElement);
    }

    public void testInsertElementAt() {

    //insert an clone of current element after the current element
      Element newElement = this.element.clone();
      this.insertElementAt(newElement, this.root.indexOf(this.element)+1);

    // insert an clone of current element before the current element
      this.insertElementAt(newElement, this.root.indexOf(this.element));
    }
  </programlisting>

  <para>
  Studying the Collection API should lead to more solutions for similar problem and you will notify that dom4j fits well in the Collection Framework and both complement
  each other in order to processing xml document in a comfortable way.
  </para>



  </section>

<section><title>Cloning - How many sheeps do you need?</title>
  <para>
  Elements can be cloned as well. Usually cloning is supported in Java with clone() method that is derived from <classname>Object</classname>, but a cloneable Object have to
  implement interface <classname>Clonable</classname>. Java support shallow copying by simply returning <emphasis>this</emphasis> for standard. dom4j supporting  deep cloning
  because shallow copies would not make sence in context of an XML object model. This means that cloning can take a while because the complete tree branch or event the document
  will be cloned. Now we have a short look <emphasis>how</emphasis> dom4j cloning mechanism is used.
  </para>

  <programlisting>

  import org.dom4j.Document;
  import org.dom4j.Element;

  public class DeployFileCreator {


   private Element cloneElement(String name) {
    return this.root.element(name).clone();
   }

   private Element cloneDetachElement(String name) {
     return this.root.createCopy(name);
   }

   public class TestElement extends junit.framework.TestCase {

     public void testCloning() throws junit.framwork.AssertionFailedException {
       assert("Test cloning with clone() failed!", this.creator.cloneElement("Key") != null);
       assert("Test cloning with createCopy() failed!", this.creator.cloneDetachElement() != null);
     }
   }
  }
  </programlisting>

  <para>
  The difference between <emphasis>createCopy(...)</emphasis> and <emphasis>clone()</emphasis> is that first is a polymorphic method that created a decoupled deep copy whereas <emphasis>clone()</emphasis> returns a returns a deep copy of the
  current document or element itself.
  </para>

  <caution><title>Consider use of Cloning</title>
   <para>
   Cloning might be usefull when you want to build a element pool. Such a pool should be desinged carefully keeping
   <classname>OutOfMemoryException</classname> in mind. You could alternativly consider to use Reference API <citation>Pawlan98</citation>
    or Dave Millers approach <citation>JavaWorldTip76</citation>.
  </para>
  </caution>

</section>
</chapter>

<chapter><title>Using dom4j with XSLT</title>
<para>
With eXtensible Stylesheet Language XML got's a powerfull method of transforming itself into other formats. Developing  Exportfilter's for dataformats are normally a hard job and so for XML XSL simpliefs that work. The aronym XSLT means the process of transformation, that is usally done by an XSL compliant Processor. XSL covers following subjects:
</para>

<itemizedlist>
  <listitem><para>XSL Style Sheet</para></listitem>
  <listitem><para>XSL Processor for XSLT</para></listitem>
  <listitem><para>FOP Processor for FOP</para></listitem>
  <listitem><para>An XML source</para></listitem>
</itemizedlist>

<para>
Since JaXP 1.1 TraX is the common API for proceeding a XSL Stylesheet inside of Java. You start with a <classname>TransformerFactory</classname> and dealing with <classname>Result</classname> and <classname>Source</classname>. A <classname>Source</classname> contains the source xml file that should be transformed. <classname>Result</classname>'s contains the the result of transformation. dom4j offers <classname>org.dom4j.io.DocumentResult</classname> and <classname>org.dom4j.io.DocumenSource</classname> for compatiblity to TrAX.
Whereas <classname>org.dom4j.io.DocumentResult</classname> contains a <classname>org.dom4j.Document</classname> as result tree, <classname>DocumentSource</classname> takes dom4j <classname>Document</classname>s and pepare them for transformation. Both classes are build on top of TraX own SAX classes. This is much more perfomant as a DOM adaptation. The following example explains the use of XSLT with TraX and dom4j.
</para>

<programlisting>
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.stream.StreamSource;

import org.dom4j.Document;
import org.dom4j.io.DocumentResult;
import org.dom4j.io.DocumentSource;

public class DocumentStyler
{
    private Transformer transformer;

    public DocumentStyler(Source aStyleSheet) throws Exception {
        // create the transformer
        TransformerFactory factory = TransformerFactory.newInstance();
        transformer = factory.newTransformer( aStyleSheet );
    }

    public Document transform(Document aDocument) throws Exception {

        // perform the transformation
        DocumentSource source = new DocumentSource( aDocument );
        DocumentResult result = new DocumentResult();
        transformer.transform(source, result);

        // return the resulting document
        return result.getDocument();
    }
}

</programlisting>

<para>
Imagine that you use XSLT to process a XML Schema in order to generate a empty template xml file accoring the schema contraints. The above sample should how easy the Java code is when you use dom4j and it's TraX support. If you use TemplateGenerator a lot you should consider the application of singleton pattern, but for this example I avoided this for simplicity. More information about TraX is provided  <ulink url="http://www.java.sun.com/xml">here</ulink>.
</para>

</chapter>

<chapter>
<title>Schemata-Support</title>

<para>
The first way to describe and constrain the form and data of a XML document is as old as XML itself.
Document Type Definitions are used since the XML Specicifiation has been published.
At lot of applications used this DTDs to describe and validate her documents. Unfortunatly
the DTD Syntax was not that powerfull as needed. Written in SGML, DTDs are also not so easy to handle as
XML is.
</para>

<para>
During the time of DTDs a couple of people invents several other possible ways that could
be used to describe a document and force its content in the desired form. Latly the
W3C published XML Schema Specification with a couple of massive inprovements. XML Schemas
are no described by XML and the way to describe a Schema is done with DTD once and not longer
by every XML user. A growing group of people using XML Schema now. But XML Schema isn't perfect.
So a few people swear by Relax or Relax NG. The reader of this document is able to choose one of
the following technologies:
</para>

<itemizedlist>
  <listitem><para>Relax NG (Regular Language description for XML Next Generation)<citation>RelaxNG</citation></para></listitem>
  <listitem><para>Relax (Regular Language description for XML)<citation>Relax</citation></para></listitem>
  <listitem><para>TREX<citation>TREX</citation></para></listitem>
  <listitem><para>XML DTDs<citation>DTD</citation></para></listitem>
  <listitem><para>XML Schema<citation>XSD</citation></para></listitem>
</itemizedlist>

<section><title>Using XML Schema Data Types in dom4j</title>
<para>
dom4j supports currently XML Schema Data Types<citation>DataTypes</citation> only.
The dom4j implementation is based on top of MSV. Earlier dom4j releases are built
on top of Suns Tranquilo (xsdlib.jar) but we use MSV now, because its uses
offers the same Tranquilo plus exiting additional features we discuss later.
</para>

<programlisting>
import java.util.List;

import org.dom4j.Document;
import org.dom4j.DocumentHelper;
import org.dom4j.XPath;
import org.dom4j.io.SAXReader;
import org.dom4j.dataType.DataTypeElement;

public class SchemaTypeDemo {

public static void main(String[] args) {

  SAXReader reader = new SAXReader();
  reader.setDocumentFactory( DatatypeDocumentFactory.getInstance() );
  Document schema =  return reader.read(xmlFile)
  XPath xpathSelector = DocumentHelper.createXPath("xsd:schema/xsd:complexType[@name='Address']/xsd:structure/xsd:element[@type]");
  List xsdElements = xpathSelector.selectNodes(schema);

  for (int i=0; i &lt; xsdElements.size(); i++) {
    DataElement tempXsdElement = (DatatypeElement)xsdElements.get(i);

    if (tempXsdElement.getData() instanceof Integer) {
       tempXsdElement.setData(new Integer(23));
     }
  }
}
</programlisting>

<caution><title>Alpha status</title>
<para>
Note that the Data Type support is still alpha. If you find any bug, please report it to
the mailing listy. This helps us to make the Data Type support more error-prone and trustworthy.
</para>
</caution>

</section>


<section><title>Validation</title>
<para>
dom4j currently comes not with its one validation engine. You are forced to use a different
engine instead. We recommend the use of Xerces 1.4.x or later in the past, but now you are
able to use Suns Multi Schema Validator as well. Xerces is able to validate against DTDs and
XML Schema, but not against TREX or Relax. You would belive it, but the Mulit Schema Validator Libery
supports all earlier mentioned types for validation.
</para>

<caution><title>Consider use of Validation</title>
<para>
Using Valdiation consumes valueable resources. Use it wisely.
</para>
</caution>

<section><title>Using Apaches Xerces 1.4.x and dom4j for validation</title>
<para>
Using Xerecs 1.4.x for Schema and Validation is very easy. You have to download
Xerces at Apaches XML web sites. The past has shown that not always the newest version
is best. You can view there mailing lists in order to find out which version is buggy
and which works well. For Schema support at least Xerecs 1.4.0 is necessary. If you
work according the following rules valdation should be no problem.
</para>

<itemizedlist>
  <listitem><para>Turn on validation mode - which is false for default - using a SAXReader instance</para></listitem>
  <listitem><para>Set the following Xerces property http://apache.org/xml/properties/schema/external-noNamespaceSchemaLocation using the schema URI.</para></listitem>
  <listitem><para>Create a SAX XMLErrorHandler and install it to your SAXReader instance.</para></listitem>
  <listitem><para>Parse and validate the Document.</para></listitem>
  <listitem><para>Output Validation/Parse Errors errors.</para></listitem>
</itemizedlist>

<programlisting>
import org.dom4j.Document;
import org.dom4j.Element;
import org.dom4j.io.OutputFormat;
import org.dom4j.io.SAXReader;
import org.dom4j.io.XMLWriter;
import org.dom4j.util.XMLErrorHandler;


import org.xml.sax.ErrorHandler;
import org.xml.sax.SAXParseException

public class SimpleValidationDemo {

public static void main(String[] args) {
  SAXReader reader = new SAXReader();

  reader.setValidation(true);

  // specify the schema to use
  reader.setProperty(
   "http://apache.org/xml/properties/schema/external-noNamespaceSchemaLocation",
   "prices.xsd"
  );

  // add an error handler which turns any errors into XML
   XMLErrorHandler errorHandler = new XMLErrorHandler();
   reader.setErrorHandler( errorHandler );

  // now lets parse the document
  Document document = reader.read(args[0]);

 // now lets output the errors as XML
  XMLWriter writer = new XMLWriter( OutputFormat.createPrettyPrint() );
  writer.write( errorHandler.getErrors() );
}

</programlisting>

<caution><title>Xerces and Crimson</title>
<para>
Both, Xerecs and Crimson, are JaXPable Parsers. You should be carefully in using
Crimson and Xerces in same classpath. Xerces will work only correct when it is the
mentioned <emphasis>before</emphasis> Crimson in classpath. At this time I
recommend that you should either Xereces <emphasis>or</emphasis> Crimson.
</para>
</caution>

</section>

<section><title>A perfect team - Multi Schema Validator<citation>MSV</citation> and dom4j </title>
<para>
Kohsuke Kawaguchi a deleloper from Sun created a extremly usefull tool for validtion of XML
documents. The Multi Schema Validator (MSV) supports following kinds of Schmemata:
</para>

<itemizedlist>
  <listitem><para>Relax NG</para></listitem>
  <listitem><para>Relax </para></listitem>
  <listitem><para>TREX</para></listitem>
  <listitem><para>XML DTDs</para></listitem>
  <listitem><para>XML Schema</para></listitem>
</itemizedlist>

<para>
You are able to use the MSV and dom4j in order to validate your Documents. The following examples shows you how to use
the MSV and with dom4j.
</para>

<programlisting>
import com.sun.msv.grammar.Grammar;
import com.sun.msv.reader.util.GrammarLoader;
import com.sun.msv.reader.util.IgnoreController;
import com.sun.msv.verifier.DocumentDeclaration;
import com.sun.msv.verifier.ValidityViolation;
import com.sun.msv.verifier.Verifier;
import com.sun.msv.verifier.VerificationErrorHandler;

import javax.xml.parsers.SAXParserFactory;

import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.io.SAXReader;
import org.dom4j.io.SAXWriter;

import org.xml.sax.ContentHandler;
import org.xml.sax.ErrorHandler;
import org.xml.sax.Locator;
import org.xml.sax.SAXParseException;

import java.net.URL;
import java.io.File;

public class Schema {

    public static void main(String argv[]) {
        try {
            String filename = argv[0];
            String schema = argv[1];

            URL fileURL = new File(filename).toURL();
            URL schemaURL = new File(schema).toURL();

            SAXReader reader = new SAXReader();
            Document doc = reader.read(fileURL);
            validate(doc, schemaURL.toExternalForm());
        } catch (Exception e) {
            e.printStackTrace(System.err);
        }
    }

    static public void validate(Document doc, String schema)
        throws Exception {

        // Turn on Namespace handling in theJAXP SAXParserFactory
        SAXParserFactory saxFactory = SAXParserFactory.newInstance();
        saxFactory.setNamespaceAware(true);

        // create MSVs DocumentDeclaration by overriding
        // a IgnoreController in an anonyous inner class
        DocumentDeclaration docDeclaration =
            GrammarLoader.loadVGM(schema, new IgnoreController() {

                    public void error(Locator[] locations,
                                      String message,
                                      Exception exception) {
                        System.out.println("ERROR: " + message);
            }

            public void error(Locator[] locations, String message) {
                System.out.println("WARNING: " + message);
            }
        }, saxFactory);

        // create a new Verifier that reports vlidation errors
        // using an anonymous inner class
        Verifier verifier =
            new Verifier(docDeclaration, new VerificationErrorHandler() {

                    public void onError(ValidityViolation e) {
                        System.out.println("Document invalid! Error: " + e);
                    }

                    public void onWarning(ValidityViolation e) {
                        System.out.println("Document invalid! Warning: " + e);
                    }
                });

        SAXWriter writer = new SAXWriter((ContentHandler) verifier);
        writer.setErrorHandler(new ErrorHandler() {

                public void error(SAXParseException e) {
                    System.out.println("ERROR:" + e);
                }

                public void fatalError(SAXParseException e) {
                    System.out.println("Fatal:" + e);
                }

                public void warning(SAXParseException e) {
                    System.out.println("Warning:" + e);
                }
        });

        // validate now!
        writer.write(doc);
        if (verifier.isValid())
            System.err.println("The document was valid");
        else
            System.err.println("The document was not valid");
    }
}
</programlisting>

<para>
At the first look the use of MSV looks not trival. The Xerces validation is
easier to use in code, but not so powerfull. Currently its not clear if XML Schema
will be the next standard for validation. Relax NG gots a even more growing
lobby. If you want to build a open application that is not fixed to a
specific XML parser and specific XML Schematas you should use this powerfull
tool.
</para>

  </section>
 </section>
</chapter>


<bibliography>
<title>Further Reading</title>

<bibliodiv><title>Books</title>
<biblioentry>
  <abbrev>XSLTReference</abbrev>
  <authorgroup>
    <author><firstname>Michael</firstname><surname>Kay</surname></author>
  </authorgroup>
  <copyright><year>2001</year>
    <holder>Worx Press, Inc.</holder>
  </copyright>
  <isbn>1-861-005067</isbn>
  <publisher>
     <publishername>Worx Press</publishername>
  </publisher>
  <title>XSLT Programmer's Reference 2'nd Edition</title>
  <seriesinfo>
    <title>Programmer To Programmer</title>
    <publisher>
      <publishername>Worx Press</publishername>
    </publisher>
  </seriesinfo>
</biblioentry>
<biblioentry>
  <abbrev>GoF95</abbrev>
  <authorgroup>
    <author><firstname>Erich</firstname><surname>Gamma</surname></author>
    <author><firstname>Richard</firstname><surname>Helm</surname></author>
    <author><firstname>Ralph</firstname><surname>Johnson</surname></author>
    <author><firstname>John</firstname><surname>Vlissides</surname></author>
  </authorgroup>
  <copyright><year>1995</year>
    <holder>Addison Wesley Pub, Co.</holder>
  </copyright>
  <isbn>0-201-633-612</isbn>
  <publisher>
     <publishername>Addison-Wesley</publishername>
  </publisher>
  <title>Design Patterns: Elements of Reusable Object-Orientated Software</title>
</biblioentry>
</bibliodiv>
</bibliography>
<bibliodiv><title>Articles</title>
<biblioentry>
  <abbrev>Pawlan98</abbrev>
  <authorgroup>
    <author><firstname>Monica</firstname><surname>Pawlan</surname></author>
  </authorgroup>
  <copyright><year>1998</year>
    <holder>http://developer.java.sun.com/javatips/jw-tips76.html</holder>
  </copyright>
  <title>Reference Objects and Garbage Collection</title>
</biblioentry>
<biblioentry>
  <abbrev>JavaTip76</abbrev>
  <authorgroup>
    <author><firstname>Dave</firstname><surname>Miller</surname></author>
  </authorgroup>
  <copyright>
    <holder>http://www.javaworld.com/javaworld/javatips/jw-javatip76.html</holder>
  </copyright>
  <title>An alternative to the deep copying technique</title>
</biblioentry>
<biblioentry>
  <abbrev>BillVenners</abbrev>
  <authorgroup>
    <author><firstname>Bill</firstname><surname>Venners</surname></author>
  </authorgroup>
  <copyright>
    <holder>http://www.artima.com/designtechniques/interfaces.html</holder>
  </copyright>
  <title>Designing with Interfaces - One Programmer's Struggle to Understand the Interface</title>
</biblioentry>
<biblioentry>
  <abbrev>Zvon</abbrev>
  <copyright>
    <holder>http://www.zvon.org/xxl/XPathTutorial/General/examples.html</holder>
  </copyright>
  <title>Zvon XPath tutorial</title>
</biblioentry>
<biblioentry>
  <abbrev>RelaxNG</abbrev>
  <copyright>
    <holder>http://www.oasis-open.org/committees/relax-ng/</holder>
  </copyright>
  <title>Developing RELAX NG, the next generation schema language for XML: clean, simple and powerful</title>
</biblioentry>
<biblioentry>
  <abbrev>Relax</abbrev>
  <copyright>
    <holder>http://www.xml.gr.jp/relax/</holder>
  </copyright>
  <title>The offical site of Relax</title>
</biblioentry>
<biblioentry>
  <abbrev>TREX</abbrev>
  <copyright>
    <holder>http://www.thaiopensource.com/trex/</holder>
  </copyright>
  <title>TREX - Tree Regular Expressions for XML</title>
</biblioentry>
<biblioentry>
  <abbrev>DTD</abbrev>
  <copyright>
    <holder>http://www.w3schools.com/dtd/default.asp</holder>
  </copyright>
  <title>Document Type Definitions Tutorial</title>
</biblioentry>
<biblioentry>
  <abbrev>XSD</abbrev>
  <copyright>
    <holder>http://www.w3.org/XML/Schema http://www.w3.org/XML/1998/06/xmlspec-report</holder>
  </copyright>
  <title>XML Schema</title>
</biblioentry>
</bibliodiv>
</book>



