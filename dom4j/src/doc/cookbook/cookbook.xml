<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.0//EN"
               "http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd">
<book>
<bookinfo>
<title>dom4j cookbook</title>
<author><firstname>Tobias</firstname><surname>Rademacher</surname></author>
<revhistory>
  <revision>
    <revnumber>0.0.6</revnumber>
    <date>01-08-03</date>
    <authorinitials>jstrachan</authorinitials>
    <revdescription>
      <itemizedlist>
        <listitem><para>Fixed a few typos and corrected the odd bit of grammar and code.</para></listitem>
      </itemizedlist>
    </revdescription>
  </revision>
  <revision>
    <revnumber>0.0.5</revnumber>
    <date>01-07-09</date>
    <authorinitials>tradem</authorinitials>
    <revdescription>
      <itemizedlist>
        <listitem><para>Fixing xml structure mistake</para></listitem>
        <listitem><para>Make Writer samples dom4j 0.6 compliant</para></listitem>
      </itemizedlist>
    </revdescription>
  </revision>
<revision>
    <revnumber>0.0.4</revnumber>
    <date>01-07-06</date>
    <authorinitials>tradem</authorinitials>
    <revdescription>
      <itemizedlist>
        <listitem><para>Fixing spelling/gramma mistakes</para></listitem>
        <listitem><para>Complete vistor listing</para></listitem>
      </itemizedlist>
    </revdescription>
</revision>
<revision>
  <revnumber>0.0.3</revnumber>
  <date>01-06-20</date>
  <authorinitials>tradem</authorinitials>
  <revdescription>
    <para>Completed doc for alpha release</para>
  </revdescription>
</revision>
<revision>
  <revnumber>0.0.2</revnumber>
  <date>01-06-06</date>
  <authorinitials>tradem</authorinitials>
  <revdescription>
    <para>Added "Secret of DocumentBuilder" and "Serialization"</para>
  </revdescription>
</revision>
<revision>
  <revnumber>0.0.1</revnumber>
  <date>01-06-02</date>
  <authorinitials>tradem</authorinitials>
  <revdescription>
    <para>Created the document</para>
  </revdescription>
  </revision>
</revhistory>
<pubdate>August 2001</pubdate>
<abstract>
  <para>This document provides a practical introduction to dom4j. It guides you through by using a lot of examples and is based on dom4j v0.8</para>
</abstract>
</bookinfo>
<preface>
  <title>Foreword</title>
<para>
</para>
</preface>
<chapter>
<title>Introducing dom4j</title>
<para>
<application>dom4j</application> is a object model representing an XML Tree in memory. 
<application>dom4j</application> offers a easy-to-use API that provides a powerfull set of 
features to process, manipulate or navigate XML and work with XPath and XSLT as well as integrate with SAX, JAXP and DOM.
</para>
<para>
<application>dom4j</application> is designed to be interface-based in order to provide highly configurable implementation strategies. 
You are able to create your own XML tree implementations by simply providing a DocumentFactory implementation.
This makes it very simple to resuse much of the dom4j code while extending it to provide whatever implementation features you wish.
</para>
<para>
This
document will guide you through <application>dom4j</application>'s features in a pratical way. 
It uses a lot of examples with source code to achive that. The document is
also desinged as a reference so that you don't have to read the entire document right now. This guide concentrates on daily work with
<application>dom4j</application> and is therefore called <emphasis>cookbook</emphasis>.
</para>
</chapter>
<chapter>
<title>Creation of an XML Object Model using dom4j</title>
<para>
Normally it all starts with a set of xml-files or a single xml file that you want to process, manipulate or navigate through to extract some
values necessary in your application. Most Java Open-Source projects using XML for deployment or as a replacement for property files in order
to get easily readable property data.
</para>

<section><title>Reading XML data</title>
<para>
How does <application>dom4j</application> help you to get at the data stored in XML? 
<application>dom4j</application> comes with a set of
builder classes that parses the xml data and creating
a tree like object structure in memory. 
You can easily manipulate and navigate through that model. 
The following example shows how you can
read your data using <application>dom4j</application> API.

<programlisting>
import java.io.File;
import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.io.SAXReader;

public class DeployFileLoaderSample {

  /** dom4j object model representation of a xml document. Note: We use the interface(!) not its implementation */
  private Document doc;

  /**
   * Loads a document from a file.
   *
   * @throw a org.dom4j.DocumentException occurs whenever the buildprocess fails.
   */
  public void parseWithSAX(File aFile) throws DocumentException {
    SAXReader xmlReader = new SAXReader();
    this.doc = xmlReader.read(aFile);
  }
}
</programlisting>

</para>

<para>
The above example code should clarify the use of <classname>org.dom4j.io.SAXReader</classname> to 
build a complete <application>dom4j</application>-tree from a given file.
The org.dom4j.io package of <application>dom4j</application> contains a set of classes 
for creating and serializing <acronym>XML</acronym> objects. 
The read() method
is overloaded so that you able to pass different kind of object that represents a source.
</para>

<itemizedlist>
  <listitem><para><classname>java.lang.String</classname> - a SystemId is a String that contains a URI e.g. a URL to a XML file</para></listitem>
  <listitem><para><classname>java.net.URL</classname> - represents a Uniform Ressource Loader or a Uniform Ressource Identifier encasulate in a URL instance</para></listitem>
  <listitem><para><classname>java.io.InputStream</classname> - a open input stream that transports xml data</para></listitem>
  <listitem><para><classname>java.io.Reader</classname> - more compartable puls the abiltiy of setting the encoding scheme</para></listitem>
  <listitem><para><classname>org.sax.InputSource</classname> - a single input source for a <acronym>XML</acronym> entity.</para></listitem>
</itemizedlist>

<para>
So we decide to add more flexiblity to our <classname>DeployFileLoaderSample</classname> and add new methods.
</para>

<programlisting>
import java.io.File;

import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.io.SAXReader;

public class DeployFileLoaderSample {

  /** dom4j object model representation of a xml document. Note: We use the interface(!) not its implementation */
  private Document doc;

  /**
   * Loads a document from a file.
   *
   * @param aFile the data source
   * @throw a org.dom4j.DocumentExcepiton occurs whenever the buildprocess fails.
   */
  public void parseWithSAX(File aFile) throws DocumentException {
    SAXReader xmlReader = new SAXReader();
    this.doc = xmlReader.read(aFile);
  }

  /**
   * Loads a document from a file.
   *
   * @param aURL the data source
   * @throw a org.dom4j.DocumentExcepiton occurs whenever the buildprocess fails.
   */
  public void parseWithSAX(URL aURL) throws DocumentException {
    SAXReader xmlReader = new SAXReader();
    this.doc = xmlReader.read(aURL);
  }


}
</programlisting>

<!-- XXXX don't understand?

<para>
Using Reflection API provides the most flexbility for handling all kinds of <classname>org.dom4j.io.SAXReader</classname> Sources, but that
and even a check with instanceof needs a good exception management while you suspend and a lot of
xml driven application will not need this flexiblity.
</para>

-->

</section>

<section>
<title>Integrating with other XML APIs</title>
<para>
<application>dom4j</application> offers also classes for integration with
the two original XML processing APIs - SAX and DOM. 
So far we have been talking about reading a document with SAX. 
The <classname>org.dom4j.SAXContentHandler</classname> class implements several
SAX interfaces directly (such as ContentHandler) so that you can embed <application>dom4j</application> 
directly inside any SAX application. 
You can also use this class to implement your own specific SAX-based Reader class if you need to.
</para>

<para>
The <classname>DOMReader</classname> class allows you to convert an existing <acronym>DOM</acronym> tree
into a <application>dom4j</application> tree.
This could be usefull if you already used DOM and want to replace it step by step 
with <application>dom4j</application> or if you just needs some of <acronym>DOM</acronym>'s 
behaviour and want to save memory ressources by transforming it in a <application>dom4j</application> Model. 
You are able to transform a DOM Document, a <acronym>DOM</acronym> node branch and a single element.
</para>

<programlisting>
import org.sax.Document;

import org.dom4j.Document;
import org.dom4j.DocumentException;
import org.dom4j.io.DOMReader;

public class DOMIntegratorSample {

  /** converts a W3C DOM document into a dom4j document */
  public Document buildDocment(org.w3c.dom.Document domDocument) {
    DOMReader xmlReader = new DOMReader();
    return xmlReader.read(domDocument);
  }
}

</programlisting>
</section>

<section><title>The secret of DocumentFactory</title>
Right now we have talked a lot of reading exisiting XML information e.g. from files, URL's or even Streams.
Sometimes it's necessary to generate a XML document from scratch within a running Java Application.
The class <classname>org.dom4j.DocumentFactory</classname> defines a set of factory methods to create documents, document
types, elements, attributes, unparsed character data (CDATA), a namespace, an <acronym>XPath</acronym> object, a NodeFilter and
some other useful instances. This makes the <classname>DocumentFactory</classname> class to a central class whenever you have to create
one of these instances by yourself.
</section>

<programlisting>

import org.dom4j.DocumentFactory;
import org.dom4j.Document;
import org.dom4j.Element;

public class DeployFileCreator {

  private DocumentFactory factory = DocumentFactory.getInstance();
  private Document doc;

  public void generateDoc(String aRootElement) {
    doc = DocumentFactory.getInstance().createDocument();
    Element root = doc.addElement(aRootElement);
  }

}

</programlisting>

<para>
The listing shows how to generate a new Document from scratch. 
The method <classname>generateDoc(String aRootElement)</classname> takes a String parameter. 
The string value contains the name of the root element of the new document. 
As you can see <classname>org.dom4j.DocumentFactory</classname> is a singleton 
that is accessable via <classname>getInstance()</classname> as most Java singletons are.
After we obtained the instance we can <classname>DocumentFactory</classname> methods. 
They follow the <emphasis>createXXX()</emphasis> naming convention, so if you want to create a Attribute you would
call <emphasis>createAttribute()</emphasis> instead. 
If your class uses DocumentFactory a lot or uses a different DocumentFactory instance then
you could add it as a member variable and initiate it via getInstance in your constructor.
</para>

<programlisting>

import org.dom4j.DocumentFactory;
import org.dom4j.Document;
import org.dom4j.Element;

public class GranuatedDeployFileCreator {

 private DocumentFactory factory;
 private Document doc;

 public GranuatedDeployFileCreator() {
   this.factory = DocumentFactory.getInstance();
 }

 public void generateDoc(String aRootElement) {
    doc = factory.createDocument();
    Element root = doc.addElement(aRootElement);
 }

}

</programlisting>



<para>
The <classname>Document</classname> and <classname>Element</classname>
interfaces have a number of helper methods for creating an XML document programmatically
in a simple way.
</para>

<programlisting>

import org.dom4j.Document;
import org.dom4j.DocumentHelper;
import org.dom4j.Element;

public class Foo {

  public Document createDocument() {
    Document document = DocumentHelper.createDocument();
    Element root = document.addElement( "root" );

    Element author2 = root.addElement( "author" )
      .addAttribute( "name", "Toby" )
      .addAttribute( "location", "Germany" )
      .addText( "Tobias Rademacher" );

    Element author1 = root.addElement( "author" )
      .addAttribute( "name", "James" )
      .addAttribute( "location", "UK" )
      .addText( "James Strachan" );
    
    return document;
  }
}

</programlisting>



<para>
As mentioned earlier <application>dom4j</application> is an interface based API. 
This means that DocumentFactory and the reader classes in the org.dom4j.io package always use the org.dom4j interfaces
rather than any concrete implementation classes.
The Collection API and <acronym>W3C</acronym>'s <acronym>DOM</acronym> are other examples of APIs that
use this design aproach.
This wide spread design is described by <citation>BillVenners</citation>.
</para>

</chapter>

<chapter>
<title>Serialization and Output</title>

<para>
Once you have parsed or created a document you want to serialize it to disk or 
into a plain (or encrypted) stream. <application>dom4j</application> provides a set of classes to serialize
your dom4j tree in four ways:
</para>

<itemizedlist>
  <listitem><para>XML</para></listitem>
  <listitem><para>HTML</para></listitem>
  <listitem><para>DOM</para></listitem>
  <listitem><para>SAX Events</para></listitem>
</itemizedlist>

<section><title>Serializing to XML</title>
<classname>org.dom4j.io.XMLWriter</classname> is a easy-to-use and easy-to-understand class used 
to serialize a <application>dom4j</application> tree to a plain <acronym>XML</acronym>. 
You are able
to write the <acronym>XML</acronym> tree to either an <classname>java.io.OutputStream</classname> 
or a <classname>java.io.Writer</classname>. 
This can be configured with the overloaded constructor or via the 
<classname>setOutputStream()</classname> or <classname>setReader()</classname> methods.
Let's have a look at a example.

<programlisting>

import java.io.OutputStream;

import org.dom4j.Document;
import org.dom4j.io.XMLWriter;
import org.dom4j.io.OutputFormat;

public class DeployFileCreator {

 private Document doc;

 public void serializetoXML(OutputStream out, String aEncodingScheme) throws Exception {
   OutputFormat outformat = OutputFormat.createPrettyPrint();
   outformat.setEncoding(aEncodingScheme);
   XMLWriter writer = new XMLWriter(out, outformat);
   writer.write(this.doc);
   writer.flush();
 }

}
</programlisting>

<para>
We use the constructor of <classname>XMLWriter</classname> to pass a to given 
<classname>OutputStream</classname> along with the required character encoding. 
It is easier to use a <classname>Writer</classname> rather than an <classname>OutputStream</classname>, 
because the <classname>Writer</classname>  is String based and so has ness 
character encoding issues.
The write() methods of <classname>Writer</classname> are overloaded so that you can write all of the dom4j objects individually if required.
</para>


<section><title>Customizing the output format</title>
<para>
The default output format is to write the XML document as-is.
If you want to change the output format then there is a class 
<classname>org.dom4j.io.OutputFormat</classname> which allows you to define pretty printing options, 
to suppress the output of the XML declaration, change the line ending and so on.
There is also a helper method <classname>OutputFormat.createPrettyPrint()</classname> which will
create a default pretty printing format that you can further customize if you wish.
</para>


<programlisting>

import java.io.OutputStream;

import org.dom4j.Document;
import org.dom4j.io.XMLWriter;
import org.dom4j.io.OutputFormat;

public class DeployFileCreator {

 private Document doc;

  public void serializetoXML(OutputStream out, String aEncodingScheme) throws Exception {
   OutputFormat outformat = OutputFormat.createPrettyPrint();
   outformat.setEncoding(aEncodingScheme);
   XMLWriter writer = new XMLWriter(out, outformat);
   writer.write(this.doc);
   writer.flush();
 }


}
</programlisting>

<para>
An interesting feature of <classname>OutputFormat</classname> the ability to set 
the character encoding. It is a good idiom to use this mechansim for setting the encoding
as the XMLWriter will be able to use this encoding to create an OutputStream as well
as to output the XML declaration.
</para>

<para>
The <classname>close()</classname> method closes the underlying <classname>Writer</classname>. 
</para>

<programlisting>

import java.io.OutputStream;

import org.dom4j.Document;
import org.dom4j.io.XMLWriter;
import org.dom4j.io.OutputFormat;

public class DeployFileCreator {

 private Document doc;
 private OutputFormat outFormat;

 public DeployFileCreator() {
   this.outFormat = OuputFormat.getPrettyPrinting();
 }

 public DeployFileCreator(OutputFormat outFormat) {
   this.outFormat = outFormat;
 }

 public void writeAsXML(OutputStream out) throws Exception {
   XMLWriter writer = new XMLWriter(outFormat, this.outFormat);
   writer.write(this.doc);
 }

 public void writeAsXML(OutputStream out, String encoding) throws Exception {
   this.outFormat.setEncoding(encoding);
   this.writeAsXML(out);
 }

}
</programlisting>

<para>
The serialization methods in our little example will now set encoding using <classname>OutputFormater</classname>. 
The default encoding if none is specifed will be <acronym>UTF-8</acronym>. 
If you need a simple output on screen for debbuing or testing you can omit setting of 
a <classname>Writer</classname> or an <classname>OutputStream</classname> completely
as <classname>XMLWriter</classname> will default to <classname>System.out</classname>.
</para>

</section>

</section>

<section><title>Printing HTML</title>
<para>
<classname>HTMLWriter</classname> takes a <application>dom4j</application> tree 
and formats it to a stream as <acronym>HTML</acronym>. This formatter is similar to
<classname>XMLWriter</classname> but outputs the text of CDATA and Entity sections rather than the serialised 
format as in <acronym>XML</acronym> and also supports many HTML element which have no corresponding close tag 
such as for &lt;BR&gt; and &lt;P&gt;
</para>

<programlisting>

import java.io.OutputStream;

import org.dom4j.Document;
import org.dom4j.io.HTMLWriter;
import org.dom4j.io.OutputFormat;

public class DeployFileCreator {

 private Document doc;
 private OutputFormat outFormat;

 public DeployFileCreator() {
   this.outFormat = OuputFormat.getPrettyPrinting();
 }

 public DeployFileCreator(OutputFormat outFormat) {
   this.outFormat = outFormat;
 }

 public void writeAsHTML(OutputStream out) throws Exception {
   HTMLWriter writer = new HTMLWriter(outFormat, this.outFormat);
   writer.write(this.doc);
   writer.flush();
 }

}
</programlisting>

</section>

<section><title>Building a DOM tree</title>
<para>
Sometimes it's necessary to transform your <application>dom4j</application> tree 
into a <acronym>DOM</acronym> tree, because you are currently refactoring your application.
<application>dom4j</application> is very convient for integration with older <acronym>XML</acronym> 
<acronym>API</acronym>'s like <acronym>DOM</acronym> or <acronym>SAX</acronym>
(see <anchor id="dom4j2SAX">Generating SAX Events</anchor>). Let's move to an example:
</para>

<programlisting>
import org.w3c.dom.Document;

import org.dom4j.Document;
import org.dom4j.io.DOMWriter;

public class DeployFileLoaderSample {

  private org.dom4j.Document doc;

  public org.w3c.dom.Document transformtoDOM() {
    DOMWriter writer = new DOMWriter(); 
    return writer.write(this.doc);
  }
}

</programlisting>

</section>

<section id="dom4j2SAX"><title>Generating SAX Events</title>
<para>
If you want to output a document as sax events in order to integrate with some existing SAX
code, you can use the <classname>org.dom4j.SAXWriter</classname> clas.
</para>


<programlisting>
import org.xml.ConentHandler;

import org.dom4j.Document;
import org.dom4j.io.SAXWriter;

public class DeployFileLoaderSample {

  private org.dom4j.Document doc;

  public void transformtoSAX(ContentHandler ctxHandler) {
     SAXWriter writer = new SAXWriter();
     writer.setContentHandler(ctxHandler);
     writer.write(doc);
  }
}

</programlisting>

<para>
Using <classname>SAXWriter</classname> is fairly easy as you can see. 
You can resolve also <classname>org.dom.Element</classname> which means that 
you are able to process a single element branch or even a single node with <acronym>SAX</acronym>.
</para>
</section>
</chapter>

<chapter>
<title>Navigation in dom4j</title>
<para>
dom4j offers several powerful mechansims for navigating through a document:-
</para>

<itemizedlist>
  <listitem><para>Using Iterators</para></listitem>
  <listitem><para>Fast index based navigation</para></listitem>
  <listitem><para>Using a backed List</para></listitem>
  <listitem><para>Using XPath</para></listitem>
  <listitem><para>In-Build GOF Visitor Pattern</para></listitem>
</itemizedlist>

<section><title>Using Iterator</title>
<para>
Most Java developers have already used java.util.Iterator or it's ancestor 
<classname>java.util.Enumeration</classname>. 
Both classe are fairly involed into the Collection API and used
to visit the elements of a collection. The Iterator is appylied usually with a while 
loop and Iterator methods hasNext() and next() item. Right now Collection API
dont support Generic Type (like C++ Templates), but there's already a Early Access Implemention available. 
Now let's move to an living example of it in dom4j.
</para>
</section>

<programlisting>

import java.util.Iterator;

import org.dom4j.Document;
import org.dom4j.Element;

public class DeployFileLoaderSample {

  private org.dom4j.Document doc;
  private org.dom4j.Element root;

  public void iterateRootChildren() {
    root = this.doc.getRootElement();
    Iterator elementIterator = root.elementIterator();
    while(elementIterator.hasNext()){
      Element elmeent = (Element)elementIterator.next();
      System.out.println(element.getName());
    }
  }
}
</programlisting>

<para>
The above example might be a little bit confusing if you are not too familiar with the Collections API. 
Casting is necessary when you want to acess the object. 
<!--
XXXX - not relevant yet?
Sometimes casting can be dangerous because of a <classname>java.lang.ClassCastException</classname>. 
dom4j normally uses a clean object model that such a exception never occurs. 
There's another interesting approach in API may be usefull.
-->
</para>

<programlisting>
import java.util.Iterator;

import org.dom4j.Document;
import org.dom4j.Element;

public class DeployFileLoaderSample {

  private org.dom4j.Document doc;
  private org.dom4j.Element root;

  public void iterateRootChildren(String aFilterElementName) {
    root = this.doc.getRootElement();
    Iterator elementIterator = root.elementIterator(aFilterElementName);
    while(elementIterator.hasNext()){
      Element elmeent = (Element)elementIterator.next();
      System.out.println(element.getName());
    }
  }
}
</programlisting>

<para>
Now the the method iterates on such Elements that have the <emphasis>same name</emphasis> as the parameterized String only. This can be used as a kind of
filter applied on top of Collection API's Iterator.
</para>

<section><title>Fast index based Navigation</title>
<para>
Sometimes if you need to walk a large tree very quickly, creating an <classname>java.io.Iterator</classname>
instance to loop through each <classname>Element</classname>'s children can be expensive in
high performance environment.
To help this situation, <application>dom4j</application> provides a fast index based looping as follows.
</para>

<programlisting>
  public void treeWalk(Document document) {
    treeWalk( document.getRootElement() );
  }

  public void treeWalk(Element element) {
    for ( int i = 0, size = element.nodeCount(); i &lt; size; i++ ) {
      Node node = element.node(i);
      if ( node instanceof Element ) {
        treeWalk( (Element) node );
      }
      else {
        // do something....
      }
    }
  }
</programlisting>


<section><title>Using a backed List</title>
<para>
You can navigate through an <classname>Element</classname>'s children
using a backed <classname>List</classname> such that modifications to the
<classname>List</classname> are reflected back into the <classname>Element</classname>.
It also means that all of the methods on <classname>List</classname> can be used.
</para>

<programlisting>
import java.util.List;

import org.dom4j.Document;
import org.dom4j.Element;

public class DeployFileLoaderSample {

  private org.dom4j.Document doc;

  public void iterateRootChildren() {
    Element root = doc.getRootElement();

    List elements = root.elements;

    // we have access to the size() and other List methods
    if ( elements.size() > 4 ) {
      // now lets remove a range of elements  
      elements.subList( 3, 4 ).clear();
    }
  }
}
</programlisting>

</section>

<section><title>Using XPath</title>
<para>
<acronym>XPath</acronym> is is one of the most usefull features of <application>dom4j</application>. 
You can use it to retrieve nodes from any location as well as evaluating complex expressions.
A good XPath refercence can be found in Micheal Kay's XSLT book <citation>XSLTReference</citation>
along with the <citation>Zvon</citation> Zvon tutorial.
</para>
</section>

<programlisting>
import java.util.Iterator;

import org.dom4j.Document;
import org.dom4j.Element;

public class DeployFileLoaderSample {

  private org.dom4j.Document doc;
  private org.dom4j.Element root;

  public void browseRootChildren() {
    List results = doc.selectNodes("/people/person[@name='Toby']")
    for ( Iterator iter = result.iterator(); iter.hasNext(); ) {
      Element element = (Element) iter.next();
      System.out.println(element.getName();
    }

    String address = doc.valueOf( "//person[@name='Toby']/address" );
    Number count = doc.numberValueOf( "//people[@location='London']" );
  }

}
</programlisting>

<para>
As selectNodes returns a List we can apply <classname>Iterator</classname> 
or any other operation avaliable on <classname>java.util.List</classname>. 
You can also select a single node via <classname>selectSingleNode()</classname>
as well as to select a String expression via <classname>valueOf()</classname>
or Number 
value of an XPath expression via <classname>numberVvalueOf()</classname>.
</para>


<section><title>Using Visitor Pattern</title>
<para>
The visitor pattern has a recrusive behavior and acts like <acronym>SAX</acronym> 
in the way that partical traversal is <emphasis>not</emphasis> possible. 
This means the complete document or the complete element branch will be visited.
 You should consider wisely when you want to use Visitor pattern, but then it 
offers a powerful and elegant way of navigation. 
This document doesn't explain Vistor Pattern in deepth, 
<citation>GoF98</citation> covers more information.
</para>

<programlisting>
import java.util.Iterator;

import org.dom4j.Visitor;
import org.dom4j.VisitorSupport;
import org.dom4j.Document;
import org.dom4j.Element;

public class VisitorSample {

  public void demo(Document doc) {

    Visitor visitor = new VisitorSupport() {
      public void visit(Element element) {
        System.out.println(
          "Entity name: " + element.getName()  + "text " + element.getText();
        );
      }
    };

    doc.accept( visitor );
  }
}

</programlisting>

<para>
As you can see we used a anonymous inner class to override the 
<classname>VisitorSupport</classname> callback adapter method 
visit(Element element) and the accept() method starts
the vistor mechansim. 
Please keep in mind that the <emphasis>complete</emphasis> element branch is visited.
</para>
</section>
</section>
</chapter>


<chapter><title>Manipulating dom4j</title>
<para>
Accessing XML content statically alone would not very special. Thus dom4j offers several methods for manipulation a documents content.
</para>

<section><title>What <classname>org.dom4j.Document</classname> provides</title>
<para>
A <classname>org.dom4j.Document</classname> allows you to configure and retreive the root element. 
You are also able to set the DOCTYPE or a SAX based <classname>EntityResolver</classname>. 
An empty <classname>Document</classname> should be created via <classname>org.dom4j.DocumentFactory</classname>.
</para>
</section>

<section><title>Working with <classname>org.dom4j.Element</classname></title>
<para>
<classname>org.dom4j.Element</classname> is a powerfull interface providing lots of methods for manipulation an Element.
</para>

<programlisting>

  public void changeElementName(String aName) {
    this.element.setName(aName);
  }

  public void changeElementText(String aText) {
    this.element.setText(aText);
  }

</programlisting>
</section>


  <section><title>Qualified Names</title>
  <para>
  An XML Element should have a qualified name. A qualified name consits normally of a Namespace and a
  local name. It's recommend to use <classname>org.dom4j.DocumentFactory</classname> to create Qualifed
  Names that are provided by <classname>org.dom4j.QName</classname> instances.
  </para>

  <programlisting>

  import org.dom4j.Element;
  import org.dom4j.Document;
  import org.dom4j.DocumentFactory;
  import org.dom4j.QName;

  public class DeployFileCreator {

   protected Document deployDoc;
   protected Element root;

   public void DeployFileCreator()
   {
     QName rootName = DocumentFactory.getInstance().createQName("preferences", "", "http://java.sun.com/dtd/preferences.dtd");
     this.root = DocumentFactory.getInstance().createElement(rootName);
     this.deployDoc = DocumentFactory.getInstance().createDocument(this.root);
   }
  }

  </programlisting>

  </section>

  <section><title>Inserting elements</title>
  <para>
  Somethimes it's necessary to insert an element somewhere in a existing XML Tree. As dom4j is based on Collection API this
  causes no problems. The following expample shows how it could be done.
  </para>

  <programlisting>

    public void insertElementAt(Element newElement, int index) {
      Element parent = this.element.getParent();
      List list = parent.content();
      list.add(index, newElement);
    }

    public void testInsertElementAt() {

    //insert an clone of current element after the current element
      Element newElement = this.element.clone();
      this.insertElementAt(newElement, this.root.indexOf(this.element)+1);

    // insert an clone of current element before the current element
      this.insertElementAt(newElement, this.root.indexOf(this.element));
    }
  </programlisting>

  <para>
  Studying the Collection API should lead to more solutions for similar problem and you will notify that dom4j fits well in the Collection Framework and both complement
  each other in order to processing xml document in a comfortable way.
  </para>



  </section>

<section><title>Cloning - How many sheeps do you need?</title>
  <para>
  Elements can be cloned as well. Usually cloning is supported in Java with clone() method that is derived from <classname>Object</classname>, but a cloneable Object have to
  implement interface <classname>Clonable</classname>. Java support shallow copying by simply returning <emphasis>this</emphasis> for standard. dom4j supporting  deep cloning
  because shallow copies would not make sence in context of an XML object model. This means that cloning can take a while because the complete tree branch or event the document
  will be cloned. Now we have a short look <emphasis>how</emphasis> dom4j cloning mechanism is used.
  </para>

  <programlisting>

  import org.dom4j.Document;
  import org.dom4j.Element;

  public class DeployFileCreator {


   private Element cloneElement(String name) {
    return this.root.element(name).clone();
   }

   private Element cloneDetachElement(String name) {
     return this.root.createCopy(name);
   }

   public class TestElement extends junit.framework.TestCase {

     public void testCloning() throws junit.framwork.AssertionFailedException {
       assert("Test cloning with clone() failed!", this.creator.cloneElement("Key") != null);
       assert("Test cloning with createCopy() failed!", this.creator.cloneDetachElement() != null);
     }
   }
  }
  </programlisting>

  <para>
  The difference between <emphasis>createCopy(...)</emphasis> and <emphasis>clone()</emphasis> is that first is a polymorphic method that created a decoupled deep copy whereas <emphasis>clone()</emphasis> returns a returns a deep copy of the
  current document or element itself. Cloning might be usefull when you want to build a element pool. Such a pool should be desinged carefully keeping
   <classname>OutOfMemoryException</classname> in mind. You could alternativly consider to use Reference API <citation>Pawlan98</citation>
    or Dave Millers approach <citation>JavaWorldTip76</citation>.
  </para>
</section>
</chapter>

<chapter><title>Using dom4j with XSLT</title>
<para>
With eXtensible Stylesheet Language XML got's a powerfull method of transforming itself into other formats. Developing  Exportfilter's for dataformats are normally a hard job and so for XML XSL simpliefs that work. The aronym XSLT means the process of transformation, that is usally done by an XSL compliant Processor. XSL covers following subjects:
</para>

<itemizedlist>
  <listitem><para>XSL Style Sheet</para></listitem>
  <listitem><para>XSL Processor for XSLT</para></listitem>
  <listitem><para>FOP Processor for FOP</para></listitem>
  <listitem><para>An XML source</para></listitem>
</itemizedlist>

<para>
Since JaXP 1.1 TraX is the common API for proceeding a XSL Stylesheet inside of Java. You start with a <classname>TransformerFactory</classname> and dealing with <classname>Result</classname> and <classname>Source</classname>. A <classname>Source</classname> contains the source xml file that should be transformed. <classname>Result</classname>'s contains the the result of transformation. dom4j offers <classname>org.dom4j.io.DocumentResult</classname> and <classname>org.dom4j.io.DocumenSource</classname> for compatiblity to TrAX.
Whereas <classname>org.dom4j.io.DocumentResult</classname> contains a <classname>org.dom4j.Document</classname> as result tree, <classname>DocumentSource</classname> takes dom4j <classname>Document</classname>s and pepare them for transformation. Both classes are build on top of TraX own SAX classes. This is much more perfomant as a DOM adaptation. The following example explains the use of XSLT with TraX and dom4j.
</para>

<programlisting>
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.stream.StreamSource;

import org.dom4j.Document;
import org.dom4j.io.DocumentResult;
import org.dom4j.io.DocumentSource;

public class TemplateGeneratorSample {

 public Source styleSheet;
 public Document schema;
 public Transformer transformer;
 public DocumentResult result;

 public class TemplateGenerator(Document aSchema, Source aStyleSheet) {
   this.styleSheet = aStyleSheet;
   this.schema  = aSchema;
   this.result = new DocumentResult();
   this.transformer = TransformerFactory.newTransformer(new StreamSource(this.styleSheet.getSystemId()));
   this.start();
 }

 public void start() {
   this.transformer.transform(this.schema, this.result);
 }

 public Document getTemplate() {
   return this.result.getDocument();
 }
}

</programlisting>

<para>
Imagine that you use XSLT to process a XML Schema in order to generate a empty template xml file accoring the schema contraints. The above sample should how easy the Java code is when you use dom4j and it's TraX support. If you use TemplateGenerator a lot you should consider the application of singleton pattern, but for this example I avoided this for simplicity. More information about TraX is provided  <ulink url="http://www.java.sun.com/xml">here</ulink>.
</para>

</chapter>

<chapter>
<title>Schema-Support</title>
</chapter>


<bibliography>
<title>Further Reading</title>

<bibliodiv><title>Books</title>
<biblioentry>
  <abbrev>XSLTReference</abbrev>
  <authorgroup>
    <author><firstname>Michael</firstname><surname>Kay</surname></author>
  </authorgroup>
  <copyright><year>2001</year>
    <holder>Worx Press, Inc.</holder>
  </copyright>
  <isbn>1-861-005067</isbn>
  <publisher>
     <publishername>Worx Press</publishername>
  </publisher>
  <title>XSLT Programmer's Reference 2'nd Edition</title>
  <seriesinfo>
    <title>Programmer To Programmer</title>
    <publisher>
      <publishername>Worx Press</publishername>
    </publisher>
  </seriesinfo>
</biblioentry>
<biblioentry>
  <abbrev>GoF95</abbrev>
  <authorgroup>
    <author><firstname>Erich</firstname><surname>Gamma</surname></author>
    <author><firstname>Richard</firstname><surname>Helm</surname></author>
    <author><firstname>Ralph</firstname><surname>Johnson</surname></author>
    <author><firstname>John</firstname><surname>Vlissides</surname></author>
  </authorgroup>
  <copyright><year>1995</year>
    <holder>Addison Wesley Pub, Co.</holder>
  </copyright>
  <isbn>0-201-633-612</isbn>
  <publisher>
     <publishername>Addison-Wesley</publishername>
  </publisher>
  <title>Design Patterns: Elements of Reusable Object-Orientated Software</title>
</biblioentry>
</bibliodiv>
</bibliography>
<bibliodiv><title>Articles</title>
<biblioentry>
  <abbrev>Pawlan98</abbrev>
  <authorgroup>
    <author><firstname>Monica</firstname><surname>Pawlan</surname></author>
  </authorgroup>
  <copyright><year>1998</year>
    <holder>http://developer.java.sun.com/javatips/jw-tips76.html</holder>
  </copyright>
  <title>Reference Objects and Garbage Collection</title>
</biblioentry>
<biblioentry>
  <abbrev>JavaTip76</abbrev>
  <authorgroup>
    <author><firstname>Dave</firstname><surname>Miller</surname></author>
  </authorgroup>
  <copyright>
    <holder>http://www.javaworld.com/javaworld/javatips/jw-javatip76.html</holder>
  </copyright>
  <title>An alternative to the deep copying technique</title>
</biblioentry>
<biblioentry>
  <abbrev>BillVenners</abbrev>
  <authorgroup>
    <author><firstname>Bill</firstname><surname>Venners</surname></author>
  </authorgroup>
  <copyright>
    <holder>http://www.artima.com/designtechniques/interfaces.html</holder>
  </copyright>
  <title>Designing with Interfaces - One Programmer's Struggle to Understand the Interface</title>
</biblioentry>
<biblioentry>
  <abbrev>Zvon</abbrev>
  <copyright>
    <holder>http://www.zvon.org/xxl/XPathTutorial/General/examples.html</holder>
  </copyright>
  <title>Zvon XPath tutorial</title>
</biblioentry>
</bibliodiv>
</book>



